
/*****************************************************************************/
/*                              Legal                                        */
/*****************************************************************************/

/*
** Copyright ©2015. Lantronix, Inc. All Rights Reserved.
** By using this software, you are agreeing to the terms of the Software
** Development Kit (SDK) License Agreement included in the distribution package
** for this software (the “License Agreement”).
** Under the License Agreement, this software may be used solely to create
** custom applications for use on the Lantronix xPico Wi-Fi product.
** THIS SOFTWARE AND ANY ACCOMPANYING DOCUMENTATION IS PROVIDED "AS IS".
** LANTRONIX SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
** TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
** FOR A PARTICULAR PURPOSE.
** LANTRONIX HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
** ENHANCEMENTS, OR MODIFICATIONS TO THIS SOFTWARE.
** IN NO EVENT SHALL LANTRONIX BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
** SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
** ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
** LANTRONIX HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/*****************************************************************************/
/*                             Includes                                      */
/*****************************************************************************/

#include "vc0706_module_defs.h" /* Automatically generated by make. */
#include "ltrx_compile_defines.h" /* Delivered with SDK. */
#include "ltrx_line.h"		/* Delivered with SDK. */
#include "main_module_libs.h" /* Delivered with SDK. */
#include "string.h"


/*****************************************************************************/
/*                              Defines                                      */
/*****************************************************************************/

#define EXPECTED_MAIN_INTERFACE_VERSION 1
#define CAMERA_MAX_BUFFER_READ 32

/*****************************************************************************/
/*                            Prototypes                                     */
/*****************************************************************************/
void sendCommand(int zeroBasedIndex, char cmd, char* args, uint8_t argn);
bool cameraBuffCtrl(int zeroBasedIndex, char command);
static bool myCBfunc(struct ltrx_http_client *client);
uint32_t getFrameLength(int zeroBasedIndex);
uint8_t* readPicture(int zeroBasedIndex, uint8_t n);
bool setImageSize(int zeroBasedIndex, uint8_t size);

/*****************************************************************************/
/*                              Globals                                      */
/*****************************************************************************/

const struct main_external_functions *g_mainExternalFunctionEntry_pointer = 0;
uint16_t frameptr = 0;

/*****************************************************************************/
/*                               Code                                        */
/*****************************************************************************/


// Define a callback function to be attached to the Lantronix web server 
// when the camera URI is accessed.
static const struct ltrx_http_dynamic_callback cb = {
	.uriPath  = "/camera",
	.callback = myCBfunc
};

// The <name>_module_initialization function is called automatically by the
// Lantronix OS when bringing up modules. This is the entry point.
void vc0706_module_initialization(const struct main_external_functions *mef)
{
	if(
		mef &&
		mef->current_interface_version >= EXPECTED_MAIN_INTERFACE_VERSION &&
        mef->backward_compatible_down_to_version <= EXPECTED_MAIN_INTERFACE_VERSION
    )
    {
        g_mainExternalFunctionEntry_pointer = mef;
		
		// Register the module so the OS does the proper initialization, like creating
		// the module directory in the filesystem to put the embedded files
		ltrx_module_register(&g_vc0706ModuleInfo);
		
		// Attach the callback to the web server. We don't need to run any more code
		// since this module will only execute code when it receives a web request
		ltrx_http_dynamic_callback_register(&cb);
    }
}

static const char* http_header = "HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: image/jpeg\r\nContent-Length: %d\r\n\r\n";

// This is the callback function
bool myCBfunc(struct ltrx_http_client *client)
{
	char buf[200];
	int zeroBasedIndex = 0;
	
	// Get the socket connection that made the request to our URI
	struct ltrx_ip_socket *socket = ltrx_http_get_socket(client);
	
	// Receive the rest of the URI line to get parameters, the URI format is:
	// /camera/x/command[/i] where:
	// x is the UART that the camera is attached to
	// command is either photo.jpg or resize
	// if command is resize, /i is the image size (1 for small, 2 for medium, 3 for large)
	const char *path = ltrx_http_get_request_path(client);
	if ( (strlen(path) > 3) && ((path[1] == '0') || (path[1] == '1')) ) {
		zeroBasedIndex = path[1]-'0';
	} else {
		return true;
	}
	if( strstr(path,"photo.jpg" ) != NULL ) {
		if (ltrx_line_open(zeroBasedIndex,1000))
		{
			if (!cameraBuffCtrl(zeroBasedIndex,0x0)) {		// Stop the Frame Buffer
				TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"Couldn't stop buffer");
				ltrx_line_close(zeroBasedIndex);
				return true;
			}
			uint32_t jpglen = getFrameLength(zeroBasedIndex);	// Get the size of the image
			//TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"Buffer size: %d", jpglen);
			snprintf(buf, 200, http_header,jpglen);	
			ltrx_ip_socket_send(socket, buf, strlen(buf), false); // Send the HTTP header to the browser
			frameptr = 0;
			while (jpglen > 0) {
				uint8_t *buffer;
				uint8_t bytesToRead = CAMERA_MAX_BUFFER_READ;
				if (jpglen < CAMERA_MAX_BUFFER_READ) { bytesToRead = jpglen; }
				// Transfer from camera transfer to our buffer. The VC0706 has a lot of errors if
				// we try to transfer more than 32 bytes at a time, so that's what CAMERA_MAX_BUFFER_READ
				// should be. Then send the data from the buffer out to the browser.
				buffer = readPicture(zeroBasedIndex,bytesToRead);
				ltrx_tcp_socket_send(socket, buffer, bytesToRead, true);
				jpglen -= bytesToRead;
			}
			cameraBuffCtrl(zeroBasedIndex,0x3);	// Restart the frame buffer
		}
		ltrx_line_close(zeroBasedIndex);
		return true;
	} else if( strstr(path,"resize") != NULL) {
		uint8_t size = *(strrchr(path, '/')+1)-'0';
		ltrx_tcp_socket_send(socket, strrchr(path,'/')+1, 1, true);
		setImageSize(zeroBasedIndex,size);
	}
	return true;
}

/* The following functions implement the protocol to talk to the VC0706 camera module.
** More information on the protocol is here:
** http://www.adafruit.com/datasheets/VC0706protocol.pdf
**
** The camera can be found here: http://www.adafruit.com/product/397
** 
** Adapted from the Adafruit VC0706 Arduino library:
** https://github.com/adafruit/Adafruit-VC0706-Serial-Camera-Library
*/

void sendCommand(int zeroBasedIndex,char cmd, char* args, uint8_t argn) {
	char head[] = {0x56,0x0};
	ltrx_line_write(zeroBasedIndex,&head,2, NULL);
	ltrx_line_write(zeroBasedIndex,&cmd,1, NULL);
	ltrx_line_write(zeroBasedIndex,&args[0],argn,NULL);
}
bool setImageSize(int zeroBasedIndex, uint8_t size) {
	char args[] = {0x05,0x04, 0x01, 0x00, 0x19, 0x22};
	uint8_t *buf;

	if (size == 2) {
		args[5] = 0x11;
	} else if (size == 3) {
		args[5] = 0x0;
	}
	sendCommand(zeroBasedIndex, 0x31, args, sizeof(args));
	if ( 	(ltrx_line_read(zeroBasedIndex,&buf,5,NULL,200) != 5) ||
			(buf[0] != 0x76) || 
			(buf[1] != 0x00) || 
			(buf[2] != 0x31) ||
			(buf[3] != 0x0) ) 
				return false;
	return true;
}
bool cameraBuffCtrl(int zeroBasedIndex, char command) {
	char args[] = {0x1,command};
	uint8_t *buf;
	sendCommand(zeroBasedIndex, 0x36, args, sizeof(args));
	if ( 	(ltrx_line_read(0,&buf,5,NULL,200) != 5) ||
			(buf[0] != 0x76) || 
			(buf[1] != 0x00) || 
			(buf[2] != 0x36) ||
			(buf[3] != 0x0) ) 
				return false;
	return true;
}
uint32_t getFrameLength(int zeroBasedIndex) {
	char args[] = {0x1, 0x00};
	uint8_t *camerabuff;
	
	sendCommand(zeroBasedIndex,0x34, args, sizeof(args));
	ltrx_line_read(zeroBasedIndex,&camerabuff,9, NULL, 2000);	
	
	uint32_t len;
	len = camerabuff[5];
	len <<= 8;
	len |= camerabuff[6];
	len <<= 8;
	len |= camerabuff[7];
	len <<= 8;
	len |= camerabuff[8];

	return len;
}
uint8_t* readPicture(int zeroBasedIndex,uint8_t n) {
	uint8_t *camerabuff;
	char args[] = {0x0C, 0x0, 0x0A, 
                    0, 0, frameptr >> 8, frameptr & 0xFF, 
                    0, 0, 0, n, 
                    0, 0x10};

	while (true) {
		sendCommand(zeroBasedIndex,0x32, args, sizeof(args));
		ltrx_line_read(zeroBasedIndex,&camerabuff,5,NULL, 200);
		if (camerabuff[3] != 0x0) {
			//TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Frame error");
			ltrx_thread_sleep(100);
			ltrx_line_purge(zeroBasedIndex);
			continue;
		}
		if ((ltrx_line_read(zeroBasedIndex,&camerabuff,n+5,NULL, 200) != n+5)) {
			//TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Could not read buffer");
			ltrx_thread_sleep(100);
			ltrx_line_purge(zeroBasedIndex);
			continue;
		}
		break;
	};
	frameptr+=n;
	return camerabuff;
}

